
#include <iostream>
using namespace std;
const int MAXN = 1000 + 10;

int main()
{
    
    int n = 6;
    int a[n],f[n];
    //cin >> n;
    int a2[] = {1,3,4,2,3,5};
    //int a2[] = {1,5,3,4,6,9,7,8};
    for (int i = 1; i <= n; i++)
    {
        //cin >> a[i];
        a[i-1] = a2[i-1];
        f[i-1] = 0x7fffffff;
        //初始值要设为INF
        /*原因很简单，每遇到一个新的元素时，就跟已经记录的f数组当前所记录的最长
        上升子序列的末尾元素相比较：如果小于此元素，那么就不断向前找，直到找到
        一个刚好比它大的元素，替换；反之如果大于，么填到末尾元素的下一个q，INF
                就是为了方便向后替换啊！*/
    }
    f[0] = a[0];
    int len = 1; //通过记录f数组的有效位数，求得个数
    /*因为上文中所提到我们有可能要不断向前寻找，
    所以可以采用二分查找的策略，这便是将时间复杂
    度降成nlogn级别的关键因素。*/
    for (int i = 2; i <= n; i++)
    {
        int l = 0, r = len, mid;
        if (a[i-1] > f[len-1])
            f[++len-1] = a[i-1];
        //如果刚好大于末尾，暂时向后顺次填充
        else 
        {
        // a[i] <= f[len], 
        // 遇到一个新的元素 a[i] 时，跟已经记录的f数组当前所记录的最长(index = len）
        // 上升子序列的末尾元素 （f[len]）相比较; 如果小于此元素（a[i] <= f[len]）, 
        // 那么就不断向前找 （索引比 len 小的位置，为了加速索引，用二分查找 mid = (L+R)/2 ），
        // 直到找到一个刚好比它大的元素 （在 f[1]~f[len]之间找一个元素，使得a[i]刚好比它大），替换；
            while (l < r)
            {
                mid = (l + r) / 2;
                if (f[mid-1] > a[i-1]) // 注意，f[i] 表示长度为i的IS序列的末尾为a[i]
                // f 是一个递增的序列，如果a[i]<f[mid],那么，mid 到 r 的元素都比 a[i] 大；
                // 需要继续在 l 到 mid 之间寻找一个元素，使得a[i]刚好比它大
                    r = mid;
                //如果仍然小于之前所记录的最小末尾，那么不断
                //向前寻找(因为是最长上升子序列，所以f数组必
                //然满足单调)
                else
                // a[i] >= f[mid]
                // a[i] 刚好比 长度为mid 的IS序列的末尾元素 f[mid]大，
                // 所以需要判断 长度为mid+1 的IS序列的末尾元素 f[mid+1] 和 a[i] 的大小
                    l = mid + 1;
            }
            f[l-1] = min(a[i-1], f[l-1]); //更新最小末尾
            // e.g. a3 = {1,3,4,2}
        }
    }
    cout << len;
    cin >> n;
    return 0;
}
